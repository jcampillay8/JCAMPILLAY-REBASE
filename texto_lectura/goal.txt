The Goals of Software Design Now that we know the purpose of software, we can give a bit of direction to our science of software design. From the purpose, we know that when we write software, we're trying to help people. So, one of the goals of a science of software design should be: To allow us to write software that is as helpful as possible. Secondly, we usually want people to continue being helped by our software. So, our second goal is: To allow our software to continue to be as helpful as possible. Now, that's a great goal, but any software system of any size is extremely complex, so allowing it to continue being helpful over time is quite a task. In fact, the major barrier today to writing and maintaining helpful software is the actual difficulty of design and programming. When software is hard to create or modify, programmers spend most of their time focusing on making things "just work," and less time focusing on helping the user. But when a system is easy to work on, programmers can spend more time focusing on being helpful to the user and less time focusing on the details of programming. Similarly, the easier it is to maintain a piece of software, the easier it is for the programmers to ensure that the software continues to be helpful. That leads us to our third goal: To design systems that can be created and maintained as easily as possible by their programmers, so that they can be--and continue to be--as helpful as possible. This third goal is the one traditionally thought of as the goal of software design, even if it's never stated explicitly. However, it's very important to also have the first and second goals to guide us. We want to remember that being helpful now and in the future are the motivations for this third goal. One thing that's important to point out about this third goal is the phrase "as easily as possible." The idea is to make our programs easy to create and maintain, not to make them difficult or complex. That doesn't mean that everything will be immediately easy --sometimes it takes time to learn a new technology or design something well--but in the long run, your choices should make the creation and maintenance of your software easier.