The Missing Science This book is mostly about something called "software design." Perhaps you've heard this term before, and maybe you've even read some books about it. But let's look at it freshly, with new, precise definitions. We know what software is. So what we really have to define is the word "design": verb 1. To make a plan for a creation. Example: The engineer will design a bridge this month and build it next month. noun 1. A plan that has been made for a creation that hasn't been built yet. Example: The engineer came up with a design for a bridge; he will build it next month. 2. The plan that an existing creation follows. Example: That bridge over there follows a good design. All of those definitions apply when we talk about software design: * When we are "designing software" ("design" as a verb), we are planning it out. There are lots of things to plan about software--the structure of the code, what technologies we're going to use, etc. There are many technical decisions to make. Often, we just make these decisions in our minds, but sometimes we also write down our plans or draw some diagrams. * Once we've done this, the result is a "software design" ("design" as the first noun definition). This is the plan that we made. Once again, this might be a written document, but it could also just be a bunch of decisions that we've made that we are now holding in our minds. * Code that already exists also has "a design," ("design" as the second noun definition), which is the structure that it has or the plan that it seems to follow. Some code may seem to have no clear structure at all--that code has "no design," meaning that there was no definite plan made by the original programmer. In between "no design" and "a design" there are also infinite shades of gray, such as "a partial 5 www.it-ebooks.info design," "several conflicting designs in one piece of code," "an almost-complete design," etc. There can also be actively bad designs that are worse than no design. For example, imagine coming across some code that had been intentionally made disorganized or complex--that would be code with an actively bad design. The science of software design is a science for making plans and decisions about software. It helps people make decisions like: * What should the structure of our program code be? * Is it more important to focus on having a fast program or a program whose code is easy to read? * For our needs, which programming language should we use? Software design does not cover subjects like: * What should the structure of the company be? * When should we have team meetings? * What times of the day should programmers work? * How should we measure the performance of our programmers? Those aren't decisions about your software, they're decisions about you or your organization. It's certainly important to make those decisions properly--many software projects have failed because they had poor management. But that is not the focus of this book. This book is about how to make the correct technical decisions about your software. Anything that involves the architecture of your software system or the technical decisions you make while creating the system falls under the category of "software design." Every Programmer Is a Designer Every programmer working on a software project is involved in design. The lead developer is in charge of designing the overall architecture of the entire program. The senior programmers are in charge of designing their own large areas. And the junior programmers are in charge of designing their parts of the program, even if they're as simple as one part of one file. There is even a certain amount of design involved in writing a single line of code. Even when you are programming all by yourself, there is still a design process that goes on. Sometimes you make a decision immediately before your fingers hit the keyboard, and that's the whole process. Sometimes you think about how you're going to write the program when you're in bed at night. 6 | Chapter 2: The Missing Science www.it-ebooks.info Everybody who writes software is a designer. Every single person on a software team is responsible for making sure that their own code is well designed. Nobody who is writing code for a software project can ignore software design, at any level. However, this does not mean that design is a democracy. You must not design by committee-- the result will be an actively bad design. Instead, all developers should have the authority to make good design decisions in their own areas. If they make poor or mediocre decisions, these should be overridden by a senior developer or the lead programmer, who should have veto power over the designers below them.1 But otherwise, responsibility for the design of code should rest with the people who are actually working on it. A designer should always be willing to listen to suggestions and feedback, because programmers are usually smart people who have good ideas. But after considering all the data, any given decision must be made by an individual, not by a group of people. The Science of Software Design Software design, as it is practiced in the world today, is not a science. What is a science? The dictionary definition is a bit complex, but basically, in order for a subject to be a science it has to pass certain tests: * A science must contain knowledge that has been collected. That is, it has to be composed of facts--not opinions--and these facts must have been put together somewhere (like in a book). * This knowledge must have some sort of organization. It has to be put into categories, the various pieces have to be correctly related to each other in terms of importance, etc. * A science must contain general truths or basic laws. * A science must tell you how to do something in the physical universe. It must be somehow applicable in work or in life. * Usually, a science is discovered and proven through the scientific method, which involves observation of the physical universe, making a theory about how the universe works, performing experiments to verify your theory, and showing that the same experiment works everywhere to demonstrate that the theory is a general truth and not just a coincidence or something that worked just for you. 1. If you are the one overriding a decision, attempt to educate the other programmer when you do it. Show how or why your decision is better than hers. If you do this, over time you will have to override that programmer less and less. Some programmers never learn, though--if after several months or years of such education a programmer continues to make numerous bad decisions, he should be removed from your team. However, most programmers are very clever people who pick things up rapidly, so this is rarely a concern. The Science of Software Design | 7 www.it-ebooks.info In the world of software, we have lots of knowledge; it's been collected in books, and it has even been somewhat organized. However, out of all the pieces required to make a science, we are missing the most important part: clearly stated laws--unshakeable truths that will never fail us. Experienced software developers know what the right thing to do is, but why is that the right thing? What makes some decisions right and some decisions wrong? What are the fundamental laws of software design? This book is the record of their discovery. It lays out a set of definitions, facts, rules, and laws for software development, mostly focused on software design. What's the difference between a fact, a rule, a definition, and a law? * Definitions tell you what something is and how you would use it. * Facts are just true statements about something. Any true piece of information is a fact. * Rules are statements that give you true advice, cover something specific, and help guide decisions, but do not necessarily help you predict what will happen in the future or figure out other truths. They usually tell you whether or not to take some action. * Laws are facts that will always be true, and that cover a broad area of knowledge. They help you figure out other important truths and allow you to predict what will happen in the future. Out of all of these, the laws are the most important. In this book, you will know that something is a law because the text will explicitly say so. If you aren't sure what category some piece of information falls into, Appendix B lists every major piece of information in the book and labels it clearly as a law, a rule, a definition, or just a plain-old fact. When you read some of these definitions, laws, rules, or facts, you may say to yourself, "That was obvious, I already knew that." That's actually quite expected--if you've been around the world of software development for a long time, you've possibly run into some of these ideas before. However, when you have this reaction, ask yourself: * Did I know that particular piece of data was proveably true? * Did I know how important it was? * Could I have communicated it clearly to another person, so that he fully understood it? * Did I understand how it related to other data in the field of software development? If you can say "yes" to some of those questions when you would previously have said "no" or "maybe," then you have gained a specific sort of understanding, and that understanding is a huge part of what differentiates a science from a mere collection of ideas. 8 | Chapter 2: The Missing Science www.it-ebooks.info Of course, this science may not be perfect yet. There is always something more to discover in the universe, more to know about any field. Sometimes there are even corrections to be made to basic laws when new data is discovered or new facts arise. But this is a starting point! It's something that can be built on: a real set of observable laws and truths for building software. Even if parts of this book are someday proven wrong and a better science is developed, it is important that one fact remain clear: software design can be a science. It is not an eternal mystery, subject to the opinion of every programmer who comes along or every consultant who wants to make a few bucks selling her "new method" of software design: There are laws, they can be known, and you can know them. They are eternal, unchanging, and fundamentally true, and they work. As to whether or not the laws in this book are the correct laws...well, there are hundreds of examples and experiments that could be cited to prove them, but in the end, you'll have to decide for yourself. Test the laws. See if you can think of any general truths about software development that are broader, or more fundamental. And if you do come up with anything or find any problems with the laws, see http://www.codesim plicity.com/ for how to contact the author with your contributions or questions. Any further developments in this subject will benefit everybody, as long as those developments really are true, fundamental laws or rules of software design. Why Has There Been No Science of Software Design? Perhaps you'd be interested to know why a science for software design didn't exist before this book. After all, we've been writing software for decades and decades now. Well, it's an interesting story. Here's some background that may help you understand how we got so far along with computers without developing a science of software design. What we think of today as "computers" started out in the minds of mathematicians as purely abstract devices--thoughts about how to solve math problems using machines instead of the mind. These mathematicians are the people we would consider the founders of computer science, which is the mathematical study of information processing. It is not, as some people believe it to be, the study of computer programming. However, the earliest computers were built under the supervision of these computer scientists by highly skilled electronic engineers. They were run by highly trained operators in tightly controlled environments. They were all custom-built by the organizations that needed them (mostly governments, to aim missiles and crack codes), and there were only one or two copies of any given model. Why Has There Been No Science of Software Design? | 9 www.it-ebooks.info Then along came UNIVAC and the world's first commercial computers. At this point, there were only so many advanced theoretical mathematicians in the world. When computers started becoming available to everybody, it clearly wasn't possible to ship a mathematician along with each one. So although some organizations, such as the United States Census Bureau (one of the first recipients of a UNIVAC), almost certainly had some highly trained operators for their machinery, other organizations undoubtedly got their machines and said, "Okay, Bill from Accounting, this is yours! Read the manual and have at it!" And there went Bill, diving into this complex machine and doing his best to make it work. Bill thereby became one of the first "working programmers." He might have studied math in school, but he almost certainly didn't study the sort of advanced theory needed to conceive and design the machine itself. Still, he could read the manual and understand it and, by trial and error, make the machine do what he wanted. Of course, the more commercial computers that were shipped, the more Bills and the fewer highly trained operators we had. The vast majority of programmers ended up just like Bill. And if there's one thing that Bill had, it was job pressure. He had demands from management to "Get that task done now!" and was told, "We don't care how it's done, just do it!" He figured out how to make the thing work according to its manual, and it did work, even if it crashed every two hours. Eventually Bill got a whole team of programmers to work with him. He had to figure out how to design a system and split up the tasks between different people. The whole art of practical programming grew organically, more like college students teaching themselves to cook than like NASA engineers building the space shuttle. So at this stage, there's a hodge-podge system of software development, and it's all very complex and hard to manage, but everybody gets along somehow. Then along came The Mythical Man Month (Addison-Wesley), a book by Fred Brooks, who actually looked at the process of software development in a real project and pointed out some facts about it--most famously, that adding programmers to a late software project makes it later. He didn't come up with a whole science, but he did make some good observations about programming and managing software development. After that came a flurry of software development methods: the Rational Unified Process, the Capability Maturity Model, Agile Software Development, and many others. None of these claimed to be a science--they were just ways of managing the complexity of software development. And that, basically, brings us up to where we are today: lots of methods, but no real science. In fact, there are two missing sciences: the science of software management and the science of software design. The science of software management would tell us how to divide up work between programmers, how to schedule releases, how to estimate the amount of time a job will 10 | Chapter 2: The Missing Science www.it-ebooks.info take, and so forth. It is being worked on actively and is addressed by the various methods mentioned above. The fact that conflicting, equally valid opinions seem to exist within the field indicates that the fundamental laws of software management have not yet been worked out. However, there is at least attention being given to the problem. The science of software design, on the other hand, gets little attention in the practical world of programming. Very few people are taught in school that there could be a science to designing software. Instead, they are mostly told, "This is how this programming language works; now go write some software!" This book exists to fill that gap. The science presented here is not computer science. That's a mathematical study. Instead, this book contains the beginnings of a science for the "working programmer"-- a set of fundamental laws and rules to follow when writing a program in any language. This is a science that's as reliable as physics or chemistry in telling you how to create an application. It has been said that such a science is not possible; that software design is too variable to ever be described by simple, fundamental laws; and that it's all just a matter of opinion. Some people also once said that understanding the physical universe was impossible because "it is the creation of God and God is unknowable," and yet we did discover sciences for the physical universe. So unless you believe that computers are unknowable, making a science of software design should be entirely possible. There is also a common myth that programming is entirely an art form, subject wholly to the personal desires of the individual programmer. However, while it's true that there is a fair bit of art involved in the application of any science, there still has to be a science there to apply, and currently there is none. The primary source of complexity in software is, in fact, the lack of this science. If programmers actually had a science for simplicity in software, there wouldn't be nearly so much complexity, and we wouldn't need crazy processes to manage that complexity.